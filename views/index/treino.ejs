<div id="canvasZone"><canvas id="renderCanvas"></canvas></div>

<%- contentFor("styles") %>

<!-- Babylon.js -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
<script src="https://cdn.babylonjs.com/recast.js"></script>
<script src="https://cdn.babylonjs.com/ammo.js"></script>
<script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script src="https://cdn.babylonjs.com/Oimo.js"></script>
<script src="https://cdn.babylonjs.com/earcut.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
<script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
<script src="<%- staticRoot %>/lib/socket.io/socket.io.min.js"></script>

<style type="text/css">
	html, body {
		margin: 0;
		padding: 0;
		min-height: 100vh;
		height: 100vh;
		overflow: hidden;
	}

	#canvasZone {
		position: relative;
		margin: 0;
		padding: 0;
		width: 100%;
		height: 100vh;
	}

	#renderCanvas {
		margin: 0;
		padding: 0;
		width: 100%;
		height: 100%;
		border: none;
		outline: none;
		user-select: none;
		touch-action: none;
	}

</style>

<%- contentFor("scripts") %>

<script type="text/javascript">
	"use strict";

	let canvas = document.getElementById("renderCanvas");
	let engine = null;
	let cena = null;
	let xrHelper = null;
	let pessoa = null;
	let cubo = null;
	let cenarios = [];
	let animacaoAtual = null;
	let socket = null;

	function alterarFundo(fundo) {
		if (!cena)
			return;

		const camera = cena.activeCamera;

		cenarios.forEach(cenario => {
			cenario.setEnabled(false);
		});

		switch (fundo) {
			case 2:
				// Montanha
				cenarios[1].setEnabled(true);
				camera.target.x = 0;
				camera.target.y = 8;
				camera.target.z = -18;
				camera.alpha = 4.78947802534579;
				camera.beta = 1.64111236477935;
				camera.radius = 10.216526823238025;
				break;

			default:
				// Academia
				cenarios[0].setEnabled(true);
				camera.target.x = 0;
				camera.target.y = 8;
				camera.target.z = -18;
				camera.alpha = 4.771078000931726;
				camera.beta = 1.321912375460505;
				camera.radius = 8.193611611048821;
				break;
		}
	}

	async function criarCena() {
		// https://doc.babylonjs.com/toolsAndResources/inspector
		// https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF
		// https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/position
		// https://playground.babylonjs.com/#WGZLGJ#11018

		cena = new BABYLON.Scene(engine);
		// Create a default skybox with an environment.
		//const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("/public/glb/environment.dds", cena);
		//const currentSkybox = cena.createDefaultSkybox(hdrTexture, true);

		let idsAdicionados = new Set();

		await BABYLON.AppendSceneAsync("/public/glb/an.glb", cena);
		let nodes = cena.getNodes();
		for (let i = nodes.length - 1; i >= 0; i--) {
			const node = nodes[i];
			if (node.id == "__root__" && !idsAdicionados.has(node.uniqueId)) {
				pessoa = node;
				const children = pessoa.getChildren();
				for (let j = 0; j < children.length; j++) {
					const child = children[j];
					if (child.id == "Cube") {
						cubo = child;
						break;
					}
				}
				idsAdicionados.add(node.uniqueId);
				break;
			}
		}

		await BABYLON.AppendSceneAsync("/public/glb/c1.glb", cena);
		nodes = cena.getNodes();
		for (let i = nodes.length - 1; i >= 0; i--) {
			const node = nodes[i];
			if (node.id == "__root__" && !idsAdicionados.has(node.uniqueId)) {
				cenarios.push(node);
				idsAdicionados.add(node.uniqueId);
				break;
			}
		}

		await BABYLON.AppendSceneAsync("/public/glb/c2.glb", cena);
		nodes = cena.getNodes();
		for (let i = nodes.length - 1; i >= 0; i--) {
			const node = nodes[i];
			if (node.id == "__root__" && !idsAdicionados.has(node.uniqueId)) {
				cenarios.push(node);
				idsAdicionados.add(node.uniqueId);
				break;
			}
		}

		cena.createDefaultCameraOrLight(true, true, true);
		//cena.createDefaultCamera(true, true, true);

		alterarFundo(1);

		cena.lights[0].direction.x = 0;
		cena.lights[0].direction.y = 0.7;
		cena.lights[0].direction.z = -0.7;

		xrHelper = await cena.createDefaultXRExperienceAsync();

		// Listar todas as animações presentes no arquivo GLB
		console.log("Animações disponíveis no arquivo GLB:");
		for (let i = 0; i < cena.animationGroups.length; i++) {
			const animation = cena.animationGroups[i];
			console.log(animation.name);
		}

		if (cena.animationGroups.length)
			reproduzirAnimacao("Base");
	}

	function reproduzirAnimacao(nome, loop = true, velocidade = 1.0) {
		if (!cena)
			return;

		if (cubo) {
			switch (parseInt(nome)) {
				case 1:
				case 2:
				case 3:
					cubo.setEnabled(true);
					break;
				default:
					cubo.setEnabled(false);
					break;
			}
		}

		// Para todas as animações em execução antes de iniciar a nova
		cena.animationGroups.forEach(animation => {
			animation.stop();
		});

		if (!nome)
			return;

		// Encontra e reproduz a animação desejada
		animacaoAtual = cena.animationGroups.find(anim => anim.name === nome);
		if (animacaoAtual) {
			animacaoAtual.start(loop, velocidade);
			animacaoAtual.targetedAnimations.forEach(targetedAnimation => {
				if (targetedAnimation.target === cubo) {
					cena.stopAnimation(cubo, targetedAnimation.animation.name);
				}
			});
			cubo.position.x = (nome === "2.L" ? -5 : 3.564);
			cubo.position.y = 5.4;
			console.log(`Reproduzindo animação: ${nome} com velocidade ${velocidade}`);
		} else {
			console.warn(`Animação não encontrada: ${nome}`);
		}
	}

	async function inicializar() {
		try {
			engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: false, stencil: false, disableWebGL2Support: false});
			await criarCena();
			inicializarSocket();
		} catch (ex) {
			alert("Erro ao criar a engine: " + ex.message || ex.toString());
		}

		window.addEventListener("resize", function () {
			engine.resize();
		});

		if (location.search.includes("debug"))
			cena.debugLayer.show();

		engine.runRenderLoop(function () {
			if (cena && cena.activeCamera) {
				cena.render();
			}
		});
	}

	function inicializarSocket() {
		// Inicializa a conexão com o servidor Socket.IO
		socket = io();

		// Evento disparado quando a conexão é estabelecida
		socket.on("connect", () => {
			console.log("Conectado ao servidor");
		});

		// Evento disparado quando a conexão é perdida
		socket.on("disconnect", () => {
			console.log("Desconectado do servidor");
		});

		// Evento para receber comandos de alteração de animação
		socket.on("reproduzirAnimacao", (dados) => {
			if (dados) {
				console.log("Recebido comando para mudar animação: ", dados.nome);
				reproduzirAnimacao(dados.nome, true, dados.velocidade / 100);
			}
		});

		// Evento para receber comandos de alteração de fundo
		socket.on("alterarFundo", (dados) => {
			if (dados) {
				console.log("Recebido comando para alterar fundo: ", dados.fundo);
				alterarFundo(parseInt(dados.fundo));
			}
		});
	}

	inicializar();

</script>
